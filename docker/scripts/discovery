#!/bin/bash
set -e

# === Terminal Colors ===
COLOR_ERROR="\033[31m"      # red
COLOR_SUCCESS="\033[32m"    # green
COLOR_NC="\033[0m"          # nocolor

# === Configuration Variables ===
RUN_DIR="/tmp/openadkit"
CYCLONEDDS_URI="${RUN_DIR}/cyclonedds.xml"
LOG_FILE="${RUN_DIR}/discovery.log"
NETPLAN_FILE="/etc/netplan/01-openadkit-netcfg.yaml"
NETPLAN_TIMEOUT=30

# === Utility ===
log() {
    local message=$1 COLOR_CODE=$2 timestamp=""
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[${timestamp}] ${message}" >> "$LOG_FILE"
    echo -e "${COLOR_CODE}${message}${COLOR_NC}" >&2
}
log_info() {
    log "$1" "${COLOR_NC}"  
}
log_error() {
    log "$1" "${COLOR_ERROR}"
}
log_success() {
    log "$1" "${COLOR_SUCCESS}"
}

print_help() {
    echo "Usage: configure.sh [OPTIONS] node_name"
    echo "Options:"
    echo "  -h | --help          Display this help message"
    echo "  -s | --server        Start as server"
    echo "  -c | --client        Start as client"
    echo "  -t | --token         (Mandatory with client) K3S server token"
    echo "  -e | --ethernets     (Optional) Configure all ethernets with static IP addresses"
    echo "  -wssid               (Optional) Set the SSID of the node"
    echo "  -wpass               (Optional) Set the password of the node"
    echo "  -d | --daemon        (Optional) Run as daemon for infinite discovery"
}

parse_args() {
    local options
    [[ $EUID -ne 0 ]] && { log_error "Script must be run as root for ethernet config"; exit 1; }
    command -v netplan >/dev/null 2>&1 || { log_error "Netplan is not installed"; exit 1; }
    grep -q "Ubuntu 22" /etc/os-release || { log_error "This script is designed for Ubuntu 22.x . Current system is not compatible."; exit 1; }
    if ! options=$(getopt -o hscedw:p:t: --long help,server,client,ethernets,daemon,wssid:,wpass:,token: -n 'parse-options' -- "$@"); then
        log_error "Failed to parse arguments"
        exit 1
    fi
    eval set -- "$options"

    while true; do
        case "$1" in
            -h|--help) print_help; exit 1 ;;
            -s|--server) option_server=true ;;
            -c|--client) option_client=true ;;
            -e|--ethernets) option_ethernets=true ;;
            -t|--token) option_token="$2"; shift ;;
            -w|--wssid) WSSID="$2"; shift ;;
            -p|--wpass) WPASS="$2"; shift ;;
            -d|--daemon) option_daemon=true ;;
            --) shift; break ;;
            *) log_error "Invalid argument: $1"; exit 1 ;;
        esac
        shift
    done
    option_name="$1"
    # Check for errors
    [[ -n "$option_server" && -n "$option_client" ]] && { log_error "Cannot be both server and client"; exit 1; }
    [[ -z "$option_server" && -z "$option_client" ]] && { log_error "Must be either server or client"; exit 1; }
    [[ -z "$option_name" ]] && { log_error "Node name is required"; exit 1; }
    [[ "$option_client" == "true" && -z "$option_token" ]] && { log_error "Token is required for client mode"; exit 1; }
    [[ -n "$WSSID" && -z "$WPASS" || -z "$WSSID" && -n "$WPASS" ]] && { log_error "Both SSID and password must be provided for WiFi configuration"; exit 1; }
    return 0
}

print_info() {
    log_info "Running node $option_name"
    [[ -n "$option_server" ]] && log_info "  as server"
    [[ -n "$option_client" ]] && log_info "  as client"
    [[ -n "$option_token" ]] && log_info "  with token: $option_token"
    [[ -n "$option_ethernets" ]] && log_info "  with ethernets"
    [[ -n "$WSSID" ]] && log_info "  with wssid: $WSSID"
    [[ -n "$WPASS" ]] && log_info "  with wpass: $WPASS"
    return 0
}

daemonize() {
    if [[ "${DAEMONIZED}" != "true" ]]; then
        log_info "Starting in daemon mode..."
        export DAEMONIZED=true
        nohup "$0" "$@" > /dev/null 2>&1 < /dev/null &
        exit 0
    fi
}

create_run_dir() {
    mkdir -p "${RUN_DIR}"
    touch "$LOG_FILE" && chmod 666 "$LOG_FILE"
    log_info "All logs can be found in ${LOG_FILE}"
}

cleanup() {
    pkill -P $$ || true
    pkill avahi-publish || true
    exit 0
}

# === Network Configuration ===
declare -g host_num=""
get_host_num() {
    if [[ -z "${host_num}" ]]; then
        local mac_address
        mac_address=$(ip link show "$(get_interfaces "ethernet" | head -n1)" | awk '/ether/ {print $2; exit}')
        host_num=$(echo "$mac_address" | tr -d ':' | cksum | cut -d' ' -f1)
        host_num=$((host_num % 253 + 2))
    else
        host_num=$((host_num + 1))
        [[ $host_num -gt 254 ]] && host_num=2
    fi
    return 0
}

get_interfaces() {
    local type=$1  # "wifi" or "ethernet"
    
    if [[ "$type" == "ethernet" ]]; then
        for iface in /sys/class/net/*; do
            iface=$(basename "$iface")
            [[ -L "/sys/class/net/$iface/device" && ! -d "/sys/class/net/$iface/wireless" ]] && echo "$iface"
        done
    elif [[ "$type" == "wifi" ]]; then
        for iface in /sys/class/net/*; do
            iface=$(basename "$iface")
            [[ -L "/sys/class/net/$iface/device" && -d "/sys/class/net/$iface/wireless" ]] && echo "$iface"
        done
    fi
}

validate_yaml() {
    if ! netplan get all &>/dev/null < "$NETPLAN_FILE"; then
        log_error "Invalid YAML configuration: \n$(cat "${NETPLAN_FILE}")"
        cleanup
    fi
    return 0
}

apply_netplan() {
    log_info "Applying netplan configuration..."
    validate_yaml
    timeout $NETPLAN_TIMEOUT netplan apply || { log_error "Netplan configuration failed"; cleanup; }
    return 0
}

configure_interfaces() {
    local config="" config_header="network:\n  version: 2\n  renderer: NetworkManager\n"
    
    if [[ "$option_ethernets" == true ]]; then
        log_info "Configuring ethernets..."
        config+="  ethernets:\n"
        for iface in $(get_interfaces "ethernet"); do
            get_host_num && log_info "Assigning static IP 10.0.0.${host_num}/24 to $iface"
            config+="    $iface:\n"
            config+="      dhcp4: true\n"
            config+="      dhcp6: true\n"
            config+="      addresses: \n      - 10.0.0.${host_num}/24\n"
            config+="      optional: true\n"
        done
    fi
    
    if [[ -n "$WSSID" && -n "$WPASS" ]]; then
        log_info "Configuring wifi..."
        config+="  wifis:\n"
        for iface in $(get_interfaces "wifi"); do
            config+="    $iface:\n"
            config+="      dhcp4: true\n"
            config+="      dhcp6: true\n"
            config+="      optional: true\n"
            config+="      access-points:\n"
            config+="        \"${WSSID}\":\n"
            config+="          password: \"${WPASS}\"\n"
        done
    fi
    
    [[ -n "$config" ]] && echo -e "$config_header$config" > "$NETPLAN_FILE" && chmod 600 "$NETPLAN_FILE" && apply_netplan && log_success "Network configuration successfully applied at ${NETPLAN_FILE}"
    return 0
}

finetune_network() {
    sysctl -w net.core.rmem_max=1073741824  # 1 GiB, default is 208 KiB
    sysctl -w net.ipv4.ipfrag_time=3  # in seconds, default is 30 s
    sysctl -w net.ipv4.ipfrag_high_thresh=134217728  # 128 MiB, default is 256 KiB
    log_success "Network finetuning applied"
    return 0
}

configure_network () {
    configure_interfaces
    command -v ufw >/dev/null 2>&1 && ufw status | grep "Status: active" && log_error "Firewall is enabled, consider disabling it for maximum DDS availability"
    finetune_network
    return 0
}

# === Discovery ===
generate_cyclonedds_xml() {
    log_info "Generating CycloneDDS configuration at ${CYCLONEDDS_URI}"
    
    cat > "$CYCLONEDDS_URI" << 'EOF'
<?xml version="1.0" encoding="UTF-8" ?>
<CycloneDDS xmlns="https://cdds.io/config" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="https://cdds.io/config https://raw.githubusercontent.com/eclipse-cyclonedds/cyclonedds/master/etc/cyclonedds.xsd">
    <Domain Id="any">
        <General>
            <Interfaces>
                <NetworkInterface autodetermine="false" name="lo" priority="default" multicast="default" />
            </Interfaces>
            <AllowMulticast>default</AllowMulticast>
            <MaxMessageSize>65500B</MaxMessageSize>
        </General>
        <Internal>
            <Watermarks>
                <WhcHigh>500kB</WhcHigh>
            </Watermarks>
        </Internal>
        <Discovery>
            <Peers>
            </Peers>
            <ParticipantIndex>auto</ParticipantIndex>
            <MaxAutoParticipantIndex>40</MaxAutoParticipantIndex>
        </Discovery>
    </Domain>
</CycloneDDS>
EOF
    chmod 666 "$CYCLONEDDS_URI"
}

add_interface () {
    local interface=$1
    grep -q "$interface" "$CYCLONEDDS_URI" 2>/dev/null && return 0
    sed -i "/<\/Interfaces>/i\                <NetworkInterface autodetermine=\"false\" name=\"$interface\" priority=\"default\" multicast=\"default\" />" "$CYCLONEDDS_URI"
}

add_address () {
    local addr=$1
    [[ "$addr" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || return 0
    grep -q "$addr" "$CYCLONEDDS_URI" 2>/dev/null && log_error "Address already exists in ${CYCLONEDDS_URI}" && return 0
    sed -i "/<\/Peers>/i\                <Peer Address=\"$addr\" />" "$CYCLONEDDS_URI"
}

declare -g node_list=""
add_node () {
    local node_name=$1 interface=$2 ip_address=$3
    [[ "$node_list" == *"$node_name"* ]] && return 0
    log_success "Adding new node $node_name with address $ip_address on interface $interface"
    add_interface "$interface"
    add_address "$ip_address"
    node_list="$node_list $node_name"
}

avahi_discover() {
    log_info "Discovering nodes..."
    local ipv4_line="" interface="" ip_address="" node_name=""
    
    while true; do
        ipv4_line=$(avahi-browse -trlp _openadkit._tcp | grep "^=.*IPv4" | head -n1) # Format: =;interface;IPv4;name;service;domain;hostname;ip;port;
        
        if [[ -n "$ipv4_line" ]]; then
            interface=$(echo "$ipv4_line" | awk -F';' '{print $2}')
            ip_address=$(echo "$ipv4_line" | awk -F';' '{print $8}')
            node_name=$(echo "$ipv4_line" | awk -F';' '{print $4}')
            add_node "$node_name" "$interface" "$ip_address"
        fi
        sleep 0.5
    done
}

avahi_publish() {
    node_name="$([[ -n "$option_server" ]] && echo "server-${option_name}" || echo "client-${option_name}")"
    log_info "Publishing node $node_name..."

    while true; do
        avahi-publish -a -s "$node_name" _openadkit._tcp 8888 || log_error "Avahi publish failed, retrying in 5 seconds..."
        sleep 5
    done
}

# === Main ===
# Initialize
trap cleanup INT TERM QUIT
create_run_dir
parse_args "$@"
[[ "${option_daemon}" == "true" ]] && daemonize "$@"
print_info
configure_network

# Run discovery
generate_cyclonedds_xml
avahi_publish & 
avahi_discover &

[[ -z "$option_daemon" ]] && sleep 2 && log_info "Running for 10 seconds..." && for _ in {1..10}; do echo -n "."; sleep 1; done && echo " done" && cleanup
wait